---
layout:     post
title:      区块链基础与应用
subtitle:   本文是对于区块链技术的学习与认识，不定时更新
date:       2019-1-20
author:     gxkyrftx
header-img: img/post-bg-unix-linux.jpg
catalog: true
tags:
    - 区块链
---
# 0.前言
比特币（BitCoin）的概念最初由中本聪在2009年提出，根据中本聪的思路设计发布的开源软件以及建构其上的P2P网络。比特币是一种P2P形式的数字货币。点对点的传输意味着一个去中心化的支付系统。
# 1.比特币的密码学原理
比特币是一种加密货币（crypto-currency),其中比特币中使用了密码学中的hash函数和签名。
## 1.1 哈希函数（cryptographic hash function）
### 1.1.1 性质

    1.collision resistance：除非使用brute-force，没有更好的方法制造碰撞
    应用于数字摘要，但是已知的哈希函数都不能通过数学方法证明其抗碰撞性，而是通过应用经验确定
    2.hiding：x——>h(x)，反推不行，除了暴力求解。
    应用：与性质1结合，作为digital commitment or digital equivalent of a sealed envelope（将结果作为哈希公布，起到了信封的功能）
    3.puzzle friendly（比特币中特有）：比特币中挖矿要求：h(block header)<=target,其中block header中的nonce是可变的，就是说，要想通过修改nonce求解出满足target的哈希值，除了一个一个的试nonce，没有更好的办法，这个性质，可以作为挖矿的工作量证明（prove of work）。

### 1.1.2 SHA-256（Secure Hash Algorithm）
比特币中的哈希函数使用了SHA-256，输出结果为256bit,详细介绍<https://blog.csdn.net/u011583927/article/details/80905740>

## 1.2 签名
1.应用了非对称加密算法（asymmetric encryption algorithm），比特币用户只需要创建一对（public key，private key），公钥相当于银行账号，私钥相当于密码。

2.用私钥签名，公钥验证合法性。

3.需要一个好的随机源（a good source of randomness）产生公私钥对。
# 2.比特币的数据结构
## 2.1 哈希指针（hash pointer）
普通c指针，指向的是一个地址，哈希指针除了指向一个地址外，还有一个哈希值。哈希指针用与无环的结构，环形会形成循环依赖。

## 2.2 区块链（block chain）
一个区块链的结构如下所示

![1](1.png)

它们之间有哈希指针连接，可以实现tamper-evident log，只需要检测most recent block的哈希指针，就可以检测出区块内容是否完整，是否被篡改。可以利用这个性质，只保存几个区块的哈希指针。

单个区块的结构如下：分为Block header（包含宏观信息）和Block body（包含实际交易）两个部分

Block header|Block body
:-:| :-:
version|transaction list
hash of previous block header
merkle root hash
target
nonce

## 2.3 Merkle tree
### 2.3.1 Merkle tree简介
相比于一般的树，使用了哈希指针，一个典型的Merkle tree如下

![2](2.png)

假如一笔交易发生变动，那么它的哈希指针会发生变化，该哈希指针的上层哈希指针也会变化，以此类推，从而导致跟哈希发生变化，可以很方便的检测。

在block的结构中，block header中包含有Merkle tree的root hash，而block body中含有的是每一笔交易的内容。

### 2.3.2 Merkle tree作用
提供Merkle prove：轻节点确认交易信息是否在区块中。

比特币系统中的节点分为全节点和轻节点，全节点包含了一个区块中交易的所有信息，轻节点只有block header。

![3](3.png)

如果要验证一个交易是否在区块中（如图黄色的transaction），可以通过Merkle prove的方法。由轻节点向全节点发出Merkle prove，全节点提供与这个交易相关的哈希指针（红色的），然后轻节点验证与transaction相关的哈希指针（绿色的），拼接起来，最终可以计算到root H（），轻节点将计算得出的哈希值与本地的哈希值作比较，相等则证明交易在区块中，不等则证明不在。

以上的证明过程是prove of membership，复杂度是对数级别的。若要证明prove of nonmembership，在Merkle tree未排序的情况下，是线性的；在排好序的Merkle tree中，复杂度是对数级别。

# 3.比特币的共识协议
## 3.1 double spending attack
数字货币本质上是一串数字，假如仅仅依靠签名确定数字货币，比特币持有者可以通过简单的复制，将这串数字复制多份，然后分别花费。在一条链上的讨论这个攻击。
## 3.2 防范措施
首先举一个例子，交易如下：

    1.用户A获得了铸币权（create coin）获得十个比特币（铸币交易）
    2.A将10个比特币转给B五个，转给C五个
    3.B给C两个，给D三个
    4.C给E七个

![4](4.png)

比特币的每笔交易都包含有输入和输出，输入是指比特币的来源，输出是指比特币转入的账户的公钥的哈希。当B想要将五个比特币给F的时候，回溯到B比特币的来源，会发现B的五个比特币是有交易记录的，已经消费了，因此这笔交易不能完成，成功阻止了double spending attack。

在交易中需要注意的问题:

    1.A需要知道B的收款地址，收款地址由B给出。而B需要知道A的公钥以验证A的身份。
    2.A的公钥由A给出，其他人不能伪造，因为每笔交易要说明币的来源。

## 3.3 共识机制
### 3.3.1 分布式共识（distributed consensus）
比特币系统的各个用户维护一个共同的分布式哈希表（distributed hash table），每一个键值对（key-value pair）都能找到对应。
分布式系统中的几个结论

    1.FLP impossibility result ,简单的说就是，在异步系统（asynchronous，网络传输时延无上限）中，即使有一个系统（faulty）是有问题的，那么这个系统就不会取得共识
    2.CAP Theorem：CAP指的是分布式系统的三个性质，C——>consistency，A——>availability，P——>partition tolerance，在一个分布式系统中，如果满足任意两个性质，则不会满足第三个性质。

### 3.3.2 比特币中的共识协议（Consensus in BitCoin）
#### 3.3.2.1 基于投票的共识协议
假设区块链系统中只有小部分节点是有恶意的，投票权（membership）由hyperledger fabric决定，这种方案是可行的。
存在的问题：女巫攻击（Sybil Attack）——在比特币系统中，恶意节点可以产生大量的用户账号，当账号数量超过一半时，就可以操纵投票结果。
#### 3.3.2.2 基于算力投票的共识协议
每个节点将合法交易在本地组装为一个区块，通过改变nonce的值，不断穷举符合条件的哈希值，然后放入Block Header，获得记账权。检查交易的合法性，最后组装成一个区块发布。
通过解puzzle的能力决定了投票的权重。
#### 3.3.2.3 最长合法链
区块链中的链的扩展应该遵循最长合法链原则，即扩展当前位置的最长的那条链。假如两个区块同时发布，链的长度相同，则节点会接收先收到的区块，然后继续计算，直到最长合法链的再次出现，另一个区块会被丢弃（orphan block）
#### 3.3.2.4 区块奖励（block reward）
当节点通过不断尝试nonce计算出满足条件的hash值时，该节点获得记账权随后可以产生一定数量的新的比特币（也就是coinbase transaction），也就是区块奖励。

区块奖励的计算

    初始为50BTC，每隔210000个比特币减半。

#### 3.3.2.5 交易费（transaction fee）
获得记账权的节点，将一笔交易记录打包进入区块后，可以获得一笔交易费。

# 4.比特币的实现
## 4.1 比特币的实例
来源于<https://www.blockchain.com/zh/btc/block/0000000000000000002c185e0e8e1c6aa99ed260eab542a582bb1b82021383d7>

![5](5.png)

比特币出现时由于算力较低，由于要满足平均10分钟出一个块的要求，所以target域也大，puzzle难度低，只需要穷举nonce就可以找到满足target的值。随着算力的增加，puzzle难度变大，只靠改变nonce有可能找不到满足target域的解，因此需要通过改变Merkle Root（64bit）与nonce（32bit），来寻找解。具体的做法跟coinbase transaction有关，先看下图

![6](6.png)

比特币的每笔交易包含着输入和输出，但是铸币交易coinbase transaction是产生比特币的源头，没有上笔交易的输入，而是获得记账权的节点向其中写入一段信息作为输入，通过不断地修改coinbae transaction中的输入，从而改变这笔交易的hash，依次向上改变Merkle Root Hash。
## 4.2 挖矿的概率分析
每次挖矿相当于是伯努利实验（Bernoulli trial），当进行了很多的伯努利试验后，这些实验就构成了伯努利分布（Bernoulli process），具有无记忆性（前面的实验结果对后面的石岩没有影响）。

对于挖矿来说，伯努利分布可以近似由泊松分布（Poisson Process）来近似，出块时间可推导出，符合指数分布（Exponential Distribution），也是具有无记忆性的，具体来说就是出块时间跟已经花费的计算时间没有关系，已经计算了十分钟没有出块，并不意味着在很短的一段时间内会出块。假如，挖矿过程中的puzzle是有记忆的，这样对算力弱的矿工是不公平的。算力强的矿工可以计算出很多次，然后相比于算力弱的矿工获得更大的优势。

## 4.3 比特币的数量
几何级数，每隔21万个区块，比特币减半，总量为

    210000*50*（1+1/2+1/4+1/8+....）=21000000

## 4.4 分叉攻击
### 4.4.1 分叉攻击例一

![7](7.png)

如图所示，A转账给M，这笔交易写入区块后，A想回滚这笔交易，将比特币转给自己，并且重新打包了一个区块。假如没有后续的6个确认区块，那么这样是完全可行的。所以在交易过程中，为了避免这样的分叉攻击，可以等6个确认区块后再确认。

### 4.4.2 分叉攻击例二
#### 4.4.2.1 selfish mining
如下图

![8](8.png)

黄色的区块为攻击者A事先计算好的，但是未发布的区块，等到M发现有6个确认区块后，完成交易,A立刻发布自己制造的区块，使其成为最长合法链，然后按照这条链继续扩展，上面的链被丢弃。

这种攻击方式在现实中不可行，因为诚实的节点是大多数的，算力也被掌握在大多数节点手中，这种做法，在计算上不可行。

#### 4.4.2.2 selfish mining的优势与风险
如下图

![9](9.png)

攻击者A由于算力足够大，在某个位置先于其他节点挖出了一个区块A1，但是它不发布这个区块，而是继续沿着A1计算A2，而此时其他节点正在计算区块其他1，这样做分散了算力，使A能够有更多的机会计算出A2。如果计算出A1后立即将A1发布，会使其他算力也向A1聚集，对A不利。

风险：A在计算A2时，区块其他1被计算出，由于A1未发布，其他链成为最长合法链，算力会聚集于这条链，更容易计算出其他2。归根到底，还是算力的竞争。

## 4.5 基于账本的交易模式（transaction-based ledger）
无法直接知道一个账号有多少比特币，只能通过一笔一笔的交易计算。比特币系统中的全节点维护了UTXO（Unspent Transaction Output），也就是未消费的交易输出的集合，它的作用是检测double spending attack之类的攻击。
## 4.6 基于账户的模式（account-based ledger）
显式记录账户金额，方便查询

# 5.比特币网络的工作原理
## 5.1 比特币网络结构 
结构|协议
:-: | :-:
application layer|BitCoin Block Chian
network layer|P2P Overlay Network

比特币网络中的节点是完全对等的，不像传统的p2p中有master node
## 5.2 比特币网络设计原则
简单（simple），鲁棒（robust），而不是高效。

比特币网络中，交易消息的传播使用flooding，牺牲了高效性，传播时不考虑下层的拓扑结构；区块的传播也使用了相同的方式，并且检测该区块是否处于最长合法链。

best effort：当一笔交易发布到比特币网络上时，不同节点收到的交易的顺序和能否收到交易时不确定的。

# 6.比特币的挖矿难度
# 6.1 挖矿难度（difficulty）
挖矿难度的改变就是通过调整target值实现的，他们之间成反比。difficulty=difficulty_1_target/target.

调整挖矿难度是因为算力的增加，使区块的产生时间不是10分钟，而是小于它。如果区块的产生时间过短，由于区块在比特币网络上传播有时延，各个节点不能统一信息，就会出现分叉，如下图。

![10](10.png)

恶意节点会通过集中算力，扩展自己的黑色链，发动51%攻击，此时的算力已经不需要51%了，因为其他的非恶意节点的算力被分散到了很多链中，当他们的算力没有恶意节点大时，由于恶意节点扩展了最长合法链，会使其他节点到最后也跟着恶意节点计算。












