---
layout:     post
title:      以太坊基础
subtitle:   本文使关于以太坊的一些基础知识，不定时更新
date:       2019-3-6
author:     gxkyrftx
header-img: img/post-bg-miui-ux.jpg
catalog: true
tags:
    - 区块链
    - 密码学
---
# 0.前言
本文为区块链的学习笔记，主要参考来源为北京大学肖臻老师《区块链技术与应用》公开课的以太坊部分,链接<https://www.bilibili.com/video/av37065233/?p=14>这门公开课使我获益匪浅，非常感谢老师的讲授!

以太坊（Ethereum）是一个开源的有智能合约功能的公共区块链平台，通过其专用加密货币以太币（Ether）提供去中心化的以太虚拟机（Ethereum Virtual Machine）来处理点对点合约。

# 1.以太坊概述
以太坊是基于ghost协议的平台，其使用的加密货币以太币，是比特币的升级版。以太币相较于比特币，出块时间短，mining puzzle不是基于算力，而是基于内存（memory，hard），限制了ASIC芯片的使用，使用权益证明（proof of work）替代工作量证明（proof of work），增加了对于智能合约(smart contract)的支持。

比特币出现后，作为一种去中心化的货币，他替代了中心化机构银行的职能，还有一些中心化机构的职能也可以被替代，例如简单逻辑结构的合同仲裁，于是就有了智能合约。当合同方来自世界各地，法律约束将会很复杂，不在同一个司法管辖权之内。即使在同一个司法管辖权内，司法程序也很复杂。而通过智能合约的方式，将规则事先写入，通过程序执行就会很简单。

# 2.基于账户的模式
以太坊基于账户模型（account-based ledger），在系统中显式记录账户余额，不像比特币需要通过UTXO计算。它能很自然的防范双花攻击，因为是基于账户余额的。但是相对的是重放攻击（replay attack），也就是收款方不诚实，想让付款方重新转钱。

如何防范重放攻击？通过增加nonce字段，将每个账户的交易编号，并且每发生一笔交易，用私钥签名。每次增加一笔交易，nonce+1.

以太坊中两类账户，外部账户（externally owned account）和合约账户（smart contract account）。外部账户也叫普通账户，公私钥对控制，有账户余额（balance），nonce。合约账户不能主动发起交易，外部账户可以调用合约账户，使这个账户调用另一个合约账户。合约账户有balance，nonce，有代码（code），相关状态存储（storage），调用的时候调用合约账户的地址。

为什么设置这种模型？比特币匿名性强，但是以太坊是需要支持智能合约的，对身份有要求，需要一个相对固定的身份。

# 3.以太坊中的数据结构
基于账户的模式，他的数据结构首先要完成从地址（address）到状态（state）的映射。以太坊中的地址，是160位，将其表示为40个十六进制的数。状态就是外部账户和合约账户的状态。

## 3.1 哈希表的可行性
首先考虑使用哈希表，因为address与state的映射类似于哈希表的key-value对，查询复杂度是常数级的。哈希表存在一个问题，

    构建merkle tree的时候，需要遍历所有的账户，提供一个根哈希，而每次有一个交易时，merkle tree就需要重新修改，代价大。

    比特币中的merkle tree的根哈希，获得记账权的节点计算出来的，基于交易，一旦写入区块链，不可改变。

## 3.2 直接将账户加入merkle tree
其次考虑将每一个地址加入merkle tree，然后计算哈希，这样的问题更大。

    1.没有提供快速查找和更新树的方法。

    2.使用unsorted merkle tree系统中全节点对于地址的排序是不唯一的，这样构建的merkle tree不是唯一的，计算出的根哈希也是不唯一的，但是实际上包含的地址是全部一样的，这样造成了全节点之间的不一致。

    3.使用unsorted merkle tree是对于账户状态的维护，不像是比特币中只有不到4000个交易，而且交易必须发布。但是账户状态不是必须要发布的，有的账户的状态没有变化，就可以不发布。

    4.使用sorted merkle tree会出现另外的一个问题，假如有一个地址想要插入到其中，一个地址的变动，可能会导致很多的哈希值的变化，代价太大。

## 3.3 MPT结构
以太坊中使用了MPT的数据结构

### 3.3.1 trie
字典树：又称单词查找树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。

一个典型的字典树如下图所示：

![1](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/1.PNG)

它的特点

    1.每个节点的分叉数目，由节点key值的取值范围决定。

    2.键值越长，需要访问内存的次数越多。

    3.只要地址不一样，trie不会产生碰撞

    4.给定输入，无论怎样的顺序输入，构造的树是同一棵树。

    5.更新局部性，插入的时候对一小部分进行修改。

    6.对于路径单一的分支，存储浪费问题很明显。

### 3.3.2 PT（Patricia Trie）
对单一路径进行压缩，成为前缀树，如下图所示

![2](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/2.PNG)

对路径进行了压缩，减少了存储浪费。路径压缩在键值稀疏的时候效果最好，对于以太坊的地址，地址长度为160位，总的地址空间为2^160,用户账户相对于这个地址空间来说是很小的，所以是稀疏的，可以进行路径压缩。

### 3.3.3 MPT（Merkle Patricia Trie）
使用哈希指针代替pt中的普通指针，有以下几个作用。

    1.写入区块头部，防止篡改

    2.提供merkle prove

    3.可以证明账户不存在，如果存在将存在的分支发过去，然后通过merkle prove进行证明，类似于比特币中的nonmember-ship证明。

### 3.3.4 Modified MPT
以太坊中对于Modified MPT的描述如下图所示

![3](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/3.png)

可以发现，在这个Modified MPT，将各个节点进行饿了细分，分为扩展节点（extension node），分支节点（branch node），叶子节点（leaf node）。在每个节点中增加了前缀，与节点的类型进行映射，

当另一个区块想加入链中时，如下图所示：

![4](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/4.png)

可以看到，一个区块的加入也是极为方便的，只需要在本地组装好状态改变的部分，然后与先前状态未改变的部分，一起组成Modified MPT即可，共享了未发生变化的节点。

在以太坊中，节点需要维护原先的历史状态，因为以太坊出块时间短，块的传播有时延，当矿工发现自己的链不是最长合法链时，需要将交易回滚，这个时候保留的状态就发挥了作用。这与比特币不同，比特币可以通过交易来推算，而以太坊中，有智能合约，有图灵完备的编程语言，这种执行过程是不可逆的，所以必须保存历史状态。

# 3.4 block header结构
以下是以太坊中block header的数据结构。来源:<https://github.com/ethereum/go-ethereum/blob/master/core/types/block.go>

~~~go
// Header represents a block header in the Ethereum blockchain.

type Header struct {
    ParentHash  common.Hash    `json:"parentHash"       gencodec:"required"`
    UncleHash   common.Hash    `json:"sha3Uncles"       gencodec:"required"`
    Coinbase    common.Address `json:"miner"            gencodec:"required"`
    Root        common.Hash    `json:"stateRoot"        gencodec:"required"`
    TxHash      common.Hash    `json:"transactionsRoot" gencodec:"required"`
    ReceiptHash common.Hash    `json:"receiptsRoot"     gencodec:"required"`
    Bloom       Bloom          `json:"logsBloom"        gencodec:"required"`
    Difficulty  *big.Int       `json:"difficulty"       gencodec:"required"`
    Number      *big.Int       `json:"number"           gencodec:"required"`
    GasLimit    uint64         `json:"gasLimit"         gencodec:"required"`
    GasUsed     uint64         `json:"gasUsed"          gencodec:"required"`
    Time        *big.Int       `json:"timestamp"        gencodec:"required"`
    Extra       []byte         `json:"extraData"        gencodec:"required"`
    MixDigest   common.Hash    `json:"mixHash"`
    Nonce       BlockNonce     `json:"nonce"`
}

~~~

关于一些字段的解释：

    UncleHash：这里的UncleHash不是和ParentHash处于同一级的

    Root：状态树的根哈希值

    TxHash：交易树的根哈希值

    ReceiptHash：收据树的根哈希值

    Bloom：提供高效的查询结果，由各个收据树的Bloom filter构成

    GasLimit，GasUsed：与交易费相关。

以下是以太坊中block的数据结构

~~~go
// Block represents an entire block in the Ethereum blockchain.

type Block struct {
    header       *Header
    uncles       []*Header
    transactions Transactions

    // caches
    
    hash atomic.Value
    size atomic.Value

    // Td is used by package core to store the total difficulty
    
    // of the chain up to and including the block.
    
    td *big.Int

    // These fields are used by package eth to track
    
    // inter-peer block relay.
    
    ReceivedAt   time.Time
    ReceivedFrom interface{}
}
~~~

关于一些字段的解释：

    header :指向区块头部的指针

    uncles ：指向uncle区块的指针，是一个数组，因为一个区块可以有很多uncle区块

    transactions：交易列表

下面是extblock，包含着发布区块的前三项。
~~~go
// "external" block encoding. used for eth protocol, etc.

type extblock struct {
    Header *Header
    Txs    []*Transaction
    Uncles []*Header
}
~~~

# 3.5 value的存储
经过RLP（recursive length profix）序列化之后存储，目标就是极简编码，最后组成的类型为嵌套字节数组（nested array of bytes）。RLP详细介绍<https://www.jianshu.com/p/a57f4e0eaeec>

# 4.交易树与收据树
数据结构：交易树与收据树的皆为MPT。

在以太坊中，多个区块的状态树共享节点，如果需要加入区块，只需要将分支加入。而状态树和 交易树只包含当前状态下的信息，没有共享的节点。

交易树与状态树的作用：

    提供merkle prove：交易树证明某个交易在区块内，收据树证明交易的执行结果。

    查询：找到符合某种条件的交易或事件。为了提供高效的查询，引入了bloom filter结构

## 4.1 Bloom Filter
Bloom filter 采用的是哈希函数的方法，将一个元素映射到一个 m长度的向量上的一个点，当这个点是 1 时，那么这个元素在集合内，反之则不在集合内。这种做法的缺陷也很明显，当有非常多的数据时，容易产生碰撞，如下图所示：

![5](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/5.PNG)

这种情况下，不能判断元素是c还是另外的元素，因为存在着碰撞。

Bloom filter会产生误报（false positive ）但是不会漏报（false negative），为减少误报，可以通过设置不同的哈希函数的方法以减少碰撞。

在Bloom filter中，无法进行删除操作，主要考虑的是哈希碰撞，一个位置对应多个元素。

以太坊中，Bloom filter存在于每笔交易的收据中，每笔交易的Bloom filter组成一个Bloom filter的并集构成整个区块的Bloom filter。当要查找满足某种条件的Bloom filter时，可以先查找区块的Bloom filter然后再根据条件查看交易的Bloom filter。

## 4.2 交易驱动的状态机
以太坊的工作过程可看作是交易驱动的状态机（transaction-driven state machine），由每一笔交易推动状态树的改变，从而推动整个系统运行。比特币系统类似，比特币系统的状态是UTXO，对一组给定的交易，状态的转移是确定的，每个全节点收到给定的交易，能从一个确定的状态转移至拎一个确定的状态。

同比特币类似，一个转账地址有可能从未在状态树中出现过，当这个地址出现时，需要将其加入到状态树中。

只将与交易相关的账户放入状态树，会出现的问题：首先账户状态不一致的问题，其次如果发生一笔交易，如下图所示。

![6](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/6.PNG)

A想转账给T，需要检查A的账户状态，但是最近的几次交易没有关于A的，只有不停地回溯，回溯到A->P的交易。同样的需要检查T的账户状态，因为这笔交易需要判断T账户的余额，然后再增加以太币，而T是一个从未出现过的账户，需要追溯到创世纪块，才发现T没出现过，才能改写T的账户状态。

## 4.3 源码解析
### 4.3.1 交易树
交易树数据结构如下：
~~~go
type Transaction struct {
    data txdata
    // caches
    
    hash atomic.Value
    size atomic.Value
    from atomic.Value
}

type txdata struct {
    AccountNonce uint64          `json:"nonce"    gencodec:"required"`
    Price        *big.Int        `json:"gasPrice" gencodec:"required"`
    GasLimit     uint64          `json:"gas"      gencodec:"required"`
    Recipient    *common.Address `json:"to"       rlp:"nil"` // nil means contract creation

    Amount       *big.Int        `json:"value"    gencodec:"required"`
    Payload      []byte          `json:"input"    gencodec:"required"`

    // Signature values
    
    V *big.Int `json:"v" gencodec:"required"`
    R *big.Int `json:"r" gencodec:"required"`
    S *big.Int `json:"s" gencodec:"required"`

    // This is only used when marshaling to JSON.
    
    Hash *common.Hash `json:"hash" rlp:"-"`
}
~~~

关键字段的解释：

    data：txdata类型。

    atomic.Value：go语言中的原子值类型，可以实现安全存储

    AccountNonce：账户交易数目，每发生一笔交易然后变化


在block.go的源码中，可以找到有关交易树的代码如下：

~~~go
if len(txs) == 0 {
        b.header.TxHash = EmptyRootHash
    } else {
        b.header.TxHash = DeriveSha(Transactions(txs))
        b.transactions = make(Transactions, len(txs))
        copy(b.transactions, txs)
    }
~~~

首先判断交易列表是否为空，空的话将交易树的根哈希赋值为EmptyRootHash。交易列表不为空，通过DeriveSha函数计算所有交易的根哈希，然后创建交易列表。

### 4.3.2 收据树
收据树的数据结构如下：来源于<https://github.com/ethereum/go-ethereum/blob/master/core/types/receipt.go>

~~~go
type Receipt struct {
    // Consensus fields
    
    PostState         []byte `json:"root"`
    Status            uint64 `json:"status"`
    CumulativeGasUsed uint64 `json:"cumulativeGasUsed" gencodec:"required"`
    Bloom             Bloom  `json:"logsBloom"         gencodec:"required"`
    Logs              []*Log `json:"logs"              gencodec:"required"`

    // Implementation fields (don't reorder!)
    
    TxHash          common.Hash    `json:"transactionHash" gencodec:"required"`
    ContractAddress common.Address `json:"contractAddress"`
    GasUsed         uint64         `json:"gasUsed" gencodec:"required"`
}

~~~

关键字段的解释：

    Bloom：就是Bloom filter

    Logs：收据记录，Bloom filter产生的来源。


计算收据树哈希的代码如下：
~~~go
if len(receipts) == 0 {
        b.header.ReceiptHash = EmptyRootHash
    } else {
        b.header.ReceiptHash = DeriveSha(Receipts(receipts))
        b.header.Bloom = CreateBloom(receipts)
    }
~~~

首先判断交易列表是否为空，空的话将收据树的根哈希赋值为EmptyRootHash。交易列表不为空，通过DeriveSha函数计算所有收据的根哈希，然后通过CreateBloom函数创建Bloom filter。

### 4.3.3 DeriveSha
两棵树都涉及到的DeriveSha函数，内容如下：来源于 <https://github.com/ethereum/go-ethereum/blob/master/core/types/derive_sha.go> 

~~~go
func DeriveSha(list DerivableList) common.Hash {
    keybuf := new(bytes.Buffer)
    trie := new(trie.Trie)
    for i := 0; i < list.Len(); i++ {
        keybuf.Reset()
        rlp.Encode(keybuf, uint(i))
        trie.Update(keybuf.Bytes(), list.GetRlp(i))
    }
    return trie.Hash()
}
~~~

可以看到首先创建了trie树，将所有的内容，通过rlp序列化，随后更新trie树，计算哈希。

### 4.3.4 CreateBloom
关于CreateBloom的源码如下：来源<https://github.com/ethereum/go-ethereum/blob/86a03f97d30c11a5321fa2f0fd37cbc4c7f63a32/core/types/bloom9.go>

~~~go
func CreateBloom(receipts Receipts) Bloom {
    bin := new(big.Int)
    for _, receipt := range receipts {
        bin.Or(bin, LogsBloom(receipt.Logs))
    }
    return BytesToBloom(bin.Bytes())
}
~~~

首先参数是整个区块的所有收据，for循环将所有收据经过LogsBloom函数处理，生成收据的Bloom filter，然后将这些Bloom filter通过or合并起来，得到整个区块的Bloom filter。

### 4.3.5 LogsBloom
LogsBloom函数的源码如下：

~~~go
func LogsBloom(logs []*Log) *big.Int {
    bin := new(big.Int)
    for _, log := range logs {
        bin.Or(bin, bloom9(log.Address.Bytes()))
        for _, b := range log.Topics {
            bin.Or(bin, bloom9(b[:]))
        }
    }
    return bin
}
~~~
主要功能是生成单个收据的Bloom filter，函数参数是log树，也是一个数组。双层for循环，外层循环将每一个log的地址取哈希然后合并加入Bloom filter；内层循环将每隔log的Topics 加入Bloom filter，这样就得到了这个收据的Bloom filter。

### 4.3.6 bloom9
bloom9是哈希函数，源码如下：

~~~go
func bloom9(b []byte) *big.Int {
    b = crypto.Keccak256(b)

    r := new(big.Int)

    for i := 0; i < 6; i += 2 {
        t := big.NewInt(1)
        b := (uint(b[i+1]) + (uint(b[i]) << 8)) & 2047
        r.Or(r, t.Lsh(t, b))
    }
    return r
}
~~~

这个函数与之前提到的将digest映射到一个位置的哈希函数不同，这里映射到了三个位置。首先通过crypto.Keccak256生成256比特（32字节）的哈希值，r是Bloom filter。然后将每两个字节拼接在一起，然后对2048取余数，得到了一个位于0-2047的结果，以太坊中Bloom filter的长度是2048位，然后将1左移b位，放入上一轮的Bloom filter中。经过三轮变换，改变三个位置。

### 4.3.7 查询Bloom filter
通过BloomLookup函数实现：

~~~go
func BloomLookup(bin Bloom, topic bytesBacked) bool {
    bloom := bin.Big()
    cmp := bloom9(topic.Bytes())

    return bloom.And(bloom, cmp).Cmp(cmp) == 0
}
~~~
先将传入的数据转成bloom9值，传入的bloomBin转成bigInt。根据按位与操作，判断传入的值是否在Bloom过滤器里面。

# 5.共识机制——GHOST协议
以太坊中的出块时间减少到了十几秒，相对于比特币有了大幅度的减少，由此带来了一个问题，区块的传播是基于p2p overlay network的，在网络上传播有时延，各个节点根据收到的块的不同，会产生临时性的状态分叉，而且是一种常态。如下图所示：

![7](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/7.PNG)

在比特币系统中，分叉的块由于不满足最长合法链原则，最终被丢弃，得不到出块奖励。如果在以太坊中使用相同的机制，会出现很大的问题。每个节点挖出的块，在以太坊中会有很大的概率被丢弃，而这些节点就相当于在白费力。与之相对的是矿池，矿池的算力强，更容易计算出下一个块，成为最长合法链，造成挖矿的集中化（mining centralization）。现实中，矿池占据了一些通信较好的节点，使其他矿工更容易接收到自己的区块，未挖出区块的矿工更倾向于扩展大型矿池挖出的区块，使其成为最长合法链的概率增加，形成恶性循环，造成中心化偏见（centralization bias）。

在以太坊中采用了GHOST协议，比特币中的丢弃块被称为叔父区块（uncle block）。协议的核心思想在于：对没有成为最长合法链的区块仍然提供一些奖励。
## 5.1 最初版本

如下图所示：

![8](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/8.PNG)

最多为两个叔父区块提供奖励。这种设计的最大的意义在于，有利于鼓励系统中出现分叉后及时合并。

缺陷在于：

    1.出现第三个分叉区块后，无法被区块包含。

    2.矿池之间存在竞争关系，有矿池故意不包含另一家矿池的叔父区块，造成损失。

    3.最长合法链扩展的太快，未包含两代之前的叔父区块。

## 5.2 升级版本

扩展了关于叔父区块的定义，如下图所示，也可以称之为叔父区块，只不过是获得的奖励不同。隔得代数越久，奖励越低，等到7代之前的分叉区块就不算叔父区块了。如下图所示：

![9](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/9.PNG)

这样设计的目的在于：

    1.控制了叔父区块的代数，避免了全节点需要维护更加庞大的状态树。

    2.出块奖励按代减少，有利于促进尽早的合并区块。

## 5.3 奖励构成
比特币系统中的奖励构成为：出块奖励+交易费

以太坊系统中的奖励构成为：出块奖励+汽油费（gas fee），叔父区块只得到出块奖励。在这里要注意：叔父区块中的交易不能执行。因为两者可能包含有相同的交易。

以太坊中对于叔父区块的奖励，只给分叉之后的地一个区块，这样有助于促进分叉的尽早合并，同时也可以防范分叉攻击。如下图所示：

![10](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/10.PNG)

假如分叉链上的每个叔父区块都获得了奖励，那么攻击者可以减小发动分叉攻击的代价，因为即使失败了，每个区块也可以拿到出块奖励。

## 5.4 实例
可以在etherscan.io中，查到一些实例，查询时间为2019/3/8，基本出块奖励为2eth。所以叔父奖励对应的值如下表：

距离|比例|实际奖励
:-:|:-:|:-:
1|7/8|1.75
2|6/8|1.5
3|5/8|1.25
4|4/8|1
5|3/8|0.75
6|2/8|0.5

关于叔父区块得到的奖励，如下图所示：来源<https://etherscan.io/uncles>

![11](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/11.PNG)

可以看到，实际系统中的分叉并不多，而且都是短分叉，分叉之后可以得到很快的合并。

一个区块包含的叔父区块的个数，可以通过打包奖励看出，如下图：

![12](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/12.PNG)

    Uncles Reward=1.75（距离为1的叔父区块）+1.5（距离为2的叔父区块）=3.25

    Block Reward=2（基本出块奖励）+0.05931647941825 （gas fee）+ 0.125（2*（1/32）*2打包奖励）

![13](https://github.com/gxkyrftx/postgraduate/raw/master/Ethereum/13.PNG)

    Uncles Reward=1.5（距离为2的叔父区块）=1.5

    Block Reward=2（基本出块奖励）+0.038512275077478098（gas fee）+ 0.0625（1*（1/32）*2打包奖励）

# 6.挖矿算法
比特币的挖矿算法，由于其基于算力进行挖矿，造成了挖矿设备的专业化，这与比特币最初的设计理念不符。“one cpu，one vote”，普通的家用电脑参与比特币的挖矿已经毫无优势。

为了抵抗挖矿设备的专业化，以太坊系统中使用了基于内存的挖矿难题（memory hard mining puzzle）。

## 6.1 莱特币（LiteCoin）
莱特币受到了比特币（BTC）的启发，并且在技术上具有相同的实现原理。

莱特币旨在改进比特币，与其相比，莱特币具有三种显著差异。

    1.莱特币网络每2.5分钟（而不是10分钟）就可以处理一个块，因此可以提供更快的交易确认。

    2.莱特币网络预期产出8400万个莱特币，是比特币网络发行货币量的四倍之多。

    3.莱特币在其工作量证明算法中使用了由Colin Percival首次提出的scrypt加密算法，这使得相比于比特币，在普通计算机上进行莱特币挖掘更为容易。


