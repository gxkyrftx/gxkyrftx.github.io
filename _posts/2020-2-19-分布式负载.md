---
layout:     post
title:      阿里分布式负载
subtitle:   阿里分布式负载
date:       2020-2-19
author:     gxkyrftx
header-img: img/post-bg-unix-linux.jpg
catalog: true
tags:
    - 随笔
---
# 1.随机算法

如果n台一样的服务器，可以是用最简单的随机算法，随机挑出一个。

---

如果有几台性能不同的，将不同性能的服务器分配不同的权值，根据权值的大小，决定使用哪一台服务器。

实现的时候有两种思路：

1.根据权值，将服务器写成list，权值为5，则写入5次。最后使用基本的随机算法从list中抽取服务器。造成内存负担。

2.权值累加，形成一个区间（0，sum），然后按照不同服务器的权值，将区间细分（0，server1）（server1，server2）。。（server n-1，sum），然后随机产生数字，数字落入哪个区间，则选择哪一台服务器。

# 2.轮询算法

如果n台一样的服务器，可以是用最简单的轮询算法，从头开始轮询，一台接一台，会造成效率的浪费。

---

如果n台性能不同的服务器，根据服务器的权重，进行轮询，权重是5，直接分配5次，这样会导致负载并不均衡，压力都在一台上。

---

n台服务器，配有权重，这个权重称之为静态权重。我们可以为其分配动态权重，初始值赋值为0，0，0.

更新过程为：将最大的静态权重减去总权重，然后再加上静态权重，重新赋值为动态权重，选择权重最大的，当权重一样时，根据轮询的基本规则选择。



![1582790500262](D:\笔记\阿里分布式负载\1.png)

# 3.哈希算法

一致性哈希算法，博客讲的比较清楚

https://www.cnblogs.com/williamjie/p/9477852.html

数据量大的时候，直接使用服务器；数据量小，使用虚拟节点，分散服务器压力

# 4.常用的分布式ID方案

分布式系统中对数据分表，一张大的表分为几张结构相同的表，容易造成ID重复，故引入分布式id。

## 4.1 uuid

Universally Unique Identifier，**通用唯一识别码**，缺点是太长了：123e4567-e89b-12d3-a456-426655440000，效率低。采用无意义字符串，没有排序。

## 4.2 数据库自增id

分布式id生成系统，必须要有高效的可用性，高效率的并发性。

可用性常用的解决方式：通过集群，多用几个

**主从数据库**：主从之间有延迟，主从之间的传输效率慢

**主主数据库**：数据库之间相互独立，但是访问序号会导致重复。可以通过给不同的数据库分配不同的步长，达到数据库同步的目的。但是又存在一个问题，加入新加入一个数据库，步长会改变，起始值也要改变，而且假如在运行过程中，一台数据库的步长更改，会导致其他多台数据库id相同，容易出错，结构容易乱。

## 4.3 数据库多主模式

## 4.4 号段模式

在数据库上层，抽象出一个分布式id服务，类似于cache，将数据库里面的id抽取一段，例如（1，1000），向上层业务提供数据信息。用完之后，重新抽取（1001，2000），一段一段的抽取。

改进，当使用到500时，提前申请500之后的，（500，1000）

## 4.5 Redis

## 4.6 雪花算法

雪花算法生成的ID是纯数字且具有时间顺序的，某一毫秒，某个机器产生的id，组成了分布式id

组成：首位无效符、时间戳差值，机器(进程)编码，序列号四部分组成。

**特点(自增、有序、适合分布式场景)**

- 时间位：可以根据时间进行排序，有助于提高查询速度。
- 机器id位：适用于分布式环境下对多节点的各个节点进行标识，可以具体根据节点数和部署情况设计划分机器位10位长度，如划分5位表示进程位等。
- 序列号位：是一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号

雪花算法在单机系统上ID是递增的，但是在分布式系统多节点的情况下，所有节点的时钟并不能保证不完全同步，所以有可能会出现不是全局递增的情况。

## 4.7 百度Uidgenerator

## 4.8 滴滴Tinyid

## 4.9 美团leaf

## 4.10 阿里seata

